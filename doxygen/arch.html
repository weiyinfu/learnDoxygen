<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> 
  <title>Doxygen manual: Doxygen's Internals</title> 
  <link href="doxygen.css" rel="stylesheet" type="text/css"> 
 </head>
 <body> <!-- Generated by Doxygen 1.3.5 --> 
  <h1><a class="anchor" name="arch">Doxygen's Internals</a></h1>
  <h3>Doxygen's internals</h3> 
  <p> <b>Note that this section is still under construction!</b></p>
  <p> The following picture shows how source files are processed by doxygen.</p>
  <p> </p>
  <div align="center"> 
   <img src="archoverview.gif" alt="archoverview.gif"> 
   <p><strong>Data flow overview</strong></p>
  </div> 
  <p> The following sections explain the steps above in more detail.</p>
  <p> </p>
  <h3>Config parser</h3> 
  <p> The configuration file that controls the settings of a project is parsed and the settings are stored in the singleton class <code>Config</code> in <code>src/config</code>.h. The parser itself is written using <code>flex</code> and can be found in <code>src/config</code>.l. This parser is also used directly by <code>doxywizard</code>, so it is put in a separate library.</p>
  <p> Each configuration option has one of 5 possible types: <code>String</code>, <code>List</code>, <code>Enum</code>, <code>Int</code>, or <code>Bool</code>. The values of these options are available through the global functions <code>Config_getXXX()</code>, where <code>XXX</code> is the type of the option. The argument of these function is a string naming the option as it appears in the configuration file. For instance: <code>Config_getBool</code>("GENERATE_TESTLIST") returns a reference to a boolean value that is <code>TRUE</code> if the test list was enabled in the config file.</p>
  <p> The function <code>readConfiguration()</code> in <code>src/doxygen</code>.cpp reads the command line options and then calls the configuration parser.</p>
  <p> </p>
  <h3>C Preprocessor</h3> 
  <p> The input files mentioned in the config file are (by default) fed to the C Preprocessor (after being piped through a user defined filter if available).</p>
  <p> The way the preprocessor works differs somewhat from a standard C Preprocessor. By default it does not do macro expansion, although it can be configured to expand all macros. Typical usage is to only expand a user specified set of macros. This is to allow macro names to appear in the type of function parameters for instance.</p>
  <p> Another difference is that the preprocessor parses, but not actually includes code when it encounters a #include (with the exception of #include found inside { ... } blocks). The reasons behind this deviation from the standard is to prevent feeding multiple definitions of the same functions/classes to doxygen's parser. If all source files would include a common header file for instance, the class and type definitions (and their documentation) would be present in each translation unit.</p>
  <p> The preprocessor is written using <code>flex</code> and can be found in <code>src/pre</code>.l. For condition blocks (#if) evaluation of constant expressions is needed. For this a <code>yacc</code> based parser is used, which can be found in <code>src/constexp</code>.y and <code>src/constexp</code>.l.</p>
  <p> The preprocessor is invoked for each file using the <code>preprocessFile()</code> function declared in <code>src/pre</code>.h, and will append the preprocessed result to a character buffer. The format of the character buffer is</p>
  <p> </p>
  <div class="fragment">
   <pre>0x06 file name 1 
0x06 preprocessed contents of file 1
...
0x06 file name n
0x06 preprocessed contents of file n
</pre>
  </div>
  <p> </p>
  <h3>Language parser</h3> 
  <p> The preprocessed input buffer is fed to the language parser, which is implemented as a big state machine using <code>flex</code>. It can be found in the file <code>src/scanner</code>.l. There is one parser for all languages (C/C++/Java/IDL). The state variables <code>insideIDL</code> and <code>insideJava</code> are uses at some places for language specific choices.</p>
  <p> The task of the parser is to convert the input buffer into a tree of entries (basically an abstract syntax tree). An entry is defined in <code>src/entry</code>.h and is a blob of loosely structured information. The most important field is <code>section</code> which specifies the kind of information contained in the entry.</p>
  <p> Possible improvements for future versions:</p>
  <ul> 
   <li>Use one scanner/parser per language instead of one big scanner.</li>
   <li>Move the first pass parsing of documentation blocks to a separate module.</li>
   <li>Parse defines (these are currently gathered by the preprocessor, and ignored by the language parser).</li>
  </ul> 
  <p> </p>
  <h3>Data organizer</h3> 
  <p> This step consists of many smaller steps, that build dictionaries of the extracted classes, files, namespaces, variables, functions, packages, pages, and groups. Besides building dictionaries, during this step relations (such as inheritance relations), between the extracted entities are computed.</p>
  <p> Each step has a function defined in <code>src/doxygen</code>.cpp, which operates on the tree of entries, built during language parsing. Look at the "Gathering information" part of <code>parseInput()</code> for details.</p>
  <p> The result of this step is a number of dictionaries, which can be found in the Doxygen "namespace" defined in <code>src/doxygen</code>.h. Most elements of these dictionaries are derived from the class <code>Definition</code>; The class <code>MemberDef</code>, for instance, holds all information for a member. An instance of such a class can be part of a file ( class <code>FileDef</code> ), a class ( class <code>ClassDef</code> ), a namespace ( class <code>NamespaceDef</code> ), a group ( class <code>GroupDef</code> ), or a Java package ( class <code>PackageDef</code> ).</p>
  <p> </p>
  <h3>Tag file parser</h3> 
  <p> If tag files are specified in the configuration file, these are parsed by a SAX based XML parser, which can be found in <code>src/tagreader</code>.cpp. The result of parsing a tag file is the insertion of <code>Entry</code> objects in the entry tree. The field <code>Entry::tagInfo</code> is used to mark the entry as external, and holds information about the tag file.</p>
  <p> </p>
  <h3>Documentation parser</h3> 
  <p> Special comment blocks are stored as strings in the entities that they document. There is a string for the brief description and a string for the detailed description. The documentation parser reads these strings and executes the commands it finds in it (this is the second pass in parsing the documentation). It writes the result directly to the output generators.</p>
  <p> The parser is written in C++ and can be found in src/docparser.cpp. The tokens that are eaten by the parser come from src/doctokenizer.l. Code fragments found in the comment blocks are passed on to the source parser.</p>
  <p> The main entry point for the documentation parser is <code>validatingParseDoc()</code> declared in <code>src/docparser</code>.h. For simple texts with special commands <code>validatingParseText()</code> is used.</p>
  <p> </p>
  <h3>Source parser</h3> 
  <p> If source browsing is enabled or if code fragments are encountered in the documentation, the source parser is invoked.</p>
  <p> The code parser tries to cross-reference to source code it parses with documented entities. It also does syntax highlighting of the sources. The output is directly written to the output generators.</p>
  <p> The main entry point for the code parser is <code>parseCode()</code> declared in <code>src/code</code>.h.</p>
  <p> </p>
  <h3>Output generators</h3> 
  <p> After data is gathered and cross-referenced, doxygen generates output in various formats. For this it uses the methods provided by the abstract class <code>OutputGenerator</code>. In order to generate output for multiple formats at once, the methods of <code>OutputList</code> are called instead. This class maintains a list of concrete output generators, where each method called is delegated to all generators in the list.</p>
  <p> To allow small deviations in what is written to the output for each concrete output generator, it is possible to temporarily disable certain generators. The OutputList class contains various <code>disable()</code> and <code>enable()</code> methods for this. The methods <code>OutputList::pushGeneratorState()</code> and <code>OutputList::popGeneratorState()</code> are used to temporarily save the set of enabled/disabled output generators on a stack.</p>
  <p> The XML is generated directly from the gathered data structures. In the future XML will be used as an intermediate language (IL). The output generators will then use this IL as a starting point to generate the specific output formats. The advantage of having an IL is that various independently developed tools written in various languages, could extract information from the XML output. Possible tools could be:</p>
  <ul> 
   <li>an interactive source browser</li>
   <li>a class diagram generator</li>
   <li>computing code metrics.</li>
  </ul> 
  <p> </p>
  <h3>Debugging</h3> 
  <p> Since doxygen uses a lot of <code>flex</code> code it is important to understand how <code>flex</code> works (for this one should read the man page) and to understand what it is doing when <code>flex</code> is parsing some input. Fortunately, when flex is used with the -d option it outputs what rules matched. This makes it quite easy to follow what is going on for a particular input fragment.</p>
  <p> To make it easier to toggle debug information for a given flex file I wrote the following perl script, which automatically adds or removes -d from the correct line in the Makefile:</p>
  <p> </p>
  <div class="fragment">
   <pre>#!/usr/local/bin/perl 

$file = shift @ARGV;
print "Toggle debugging mode for $file\n";

# add or remove the -d flex flag in the makefile
unless (rename "Makefile.libdoxygen","Makefile.libdoxygen.old") {
  print STDERR "Error: cannot rename Makefile.libdoxygen!\n";
  exit 1;
}
if (open(F,"&lt;Makefile.libdoxygen.old")) {
  unless (open(G,"&gt;Makefile.libdoxygen")) {
    print STDERR "Error: opening file Makefile.libdoxygen for writing\n";
    exit 1; 
  }
  print "Processing Makefile.libdoxygen...\n";
  while (&lt;F&gt;) {
    if ( s/\(LEX\) -P([a-z]+)YY -t $file/(LEX) -d -P\1YY -t $file/g ) {
      print "Enabling debug info for $file\n";
    }
    elsif ( s/\(LEX\) -d -P([a-z]+)YY -t $file/(LEX) -P\1YY -t $file/g ) {
      print "Disabling debug info for $file\n";
    }
    print G "$_";
  }
  close F;
  unlink "Makefile.libdoxygen.old";
}
else {
  print STDERR "Warning file Makefile.libdoxygen.old does not exist!\n"; 
}

# touch the file
$now = time;
utime $now, $now, $file
</pre>
  </div>
  <hr size="1">
  <address style="align: right;"><small>Generated on Thu Feb 5 16:59:09 2004 for Doxygen manual by <a href="../../../../../www.doxygen.org/index.html"> <img src="doxygen.png" alt="doxygen" align="middle" border="0"> </a>1.3.5 </small></address>  
 </body>
</html>